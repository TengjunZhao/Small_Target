# 一、服务器初始化（首次登录）

1. 登录服务器（可选）

```bash
# 本地终端连接服务器（替换为你的服务器公网IP）
ssh root@你的服务器公网IP
# 输入服务器root密码完成登录
```

2. 更新系统并安装基础依赖

```bash
# 更新系统软件包（确保后续安装无依赖问题）
apt update && apt upgrade -y

# 安装基础工具（编译、网络、解压等）
apt install -y build-essential wget curl git unzip net-tools
```

3. 配置防火墙（放行必要端口）

```bash
# 查看防火墙状态
ufw status

# 启用防火墙（首次启用会提示，输入y确认）
ufw enable

# 放行SSH（22）、HTTP（80）、HTTPS（443）、Django调试（8000，可选）、PostgreSQL（5432，仅内网用）
ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw allow 8000/tcp  # 测试阶段用，生产环境可关闭
ufw allow 5342/tcp  # PostgreSQL连接数据库
# 查看放行结果
ufw status
```

# 二、安装并配置 PostgreSQL 数据库

1. 安装 PostgreSQL

```bash
# 安装PostgreSQL及配套工具（Ubuntu 22.04默认是14版本，稳定且适配Django）
apt install -y postgresql postgresql-contrib libpq-dev
```

2. 初始化数据库配置

```bash
# 切换到postgres系统用户（PostgreSQL默认管理员）
su - postgres

# 进入PostgreSQL命令行
psql

# 1. 创建Django项目专用数据库（替换为你的数据库名，如django_vue_db）
CREATE DATABASE django_vue_db;

# 2. 创建数据库用户（替换为你的用户名和密码，如db_user/123456）
CREATE USER db_user WITH PASSWORD '你的数据库密码';

# 3. 配置用户权限（赋予该用户数据库的全部权限）
ALTER ROLE db_user SET client_encoding TO 'utf8';
ALTER ROLE db_user SET default_transaction_isolation TO 'read committed';
ALTER ROLE db_user SET timezone TO 'Asia/Shanghai';
GRANT ALL PRIVILEGES ON DATABASE django_vue_db TO db_user;

# 退出PostgreSQL命令行
\q

# 退出postgres用户，回到root
exit
```

3. 调整 PostgreSQL 访问权限（允许 Django 连接）

```bash
# 编辑配置文件，修改监听地址和认证方式
vim /etc/postgresql/16/main/postgresql.conf

# 找到 listen_addresses = 'localhost' 这一行，修改为（允许本机访问即可）：
listen_addresses = '127.0.0.1'
# 保存退出（vim操作：按i编辑，编辑完按esc，输入:wq回车）

# 编辑认证配置文件
vim /etc/postgresql/16/main/pg_hba.conf

# 找到 "local   all             all                                     peer" 这一行，修改为：
local   all             all                                     md5
# 保存退出

# 重启PostgreSQL服务使配置生效
systemctl restart postgresql
# 设置开机自启
systemctl enable postgresql

# 验证服务状态（显示active (running)则正常）
systemctl status postgresql
```

```
# "local" is for Unix domain socket connections only
local   all             all                                     md5
# IPv4 local connections:
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     peer
host    replication     all             127.0.0.1/32            scram-sha-256
host    replication     all             ::1/128                 scram-sha-256
# 让postgresql监听外部工具的连接
host    all             all             0.0.0.0/0               md5
```

# 三、安装 Python 环境与部署 Django 后端

1. 安装 Python 及虚拟环境（避免全局环境冲突）

```bash
# Ubuntu 22.04自带Python3.10，先安装pip和虚拟环境工具
apt install -y python3-pip python3-venv

# 升级pip到最新版本
pip3 install --upgrade pip

# 创建项目目录（统一管理后端代码）
mkdir -p /www/django_project
cd /www/django_project

# 创建虚拟环境（命名为venv，隔离依赖）
python3 -m venv venv

# 激活虚拟环境（后续Django操作都要在激活状态下执行）
source venv/bin/activate
# 激活后终端前缀会显示 (venv)
```

2. 上传 Django 代码并安装依赖

```bash
# 方式1：通过Git拉取代码（推荐，前提是代码已上传到Git仓库）
git clone 你的Django项目Git地址 .

# 方式2：本地上传（如果没有Git，用scp命令，在本地终端执行）
# scp -r 本地Django项目路径 root@服务器IP:/www/django_project/

# 安装Django项目依赖（确保项目根目录有requirements.txt）
pip install -r requirements.txt

# 必装依赖（如果requirements.txt里没有）
pip install django psycopg2-binary gunicorn  # psycopg2-binary是PostgreSQL的Python驱动，gunicorn是生产环境WSGI服务器
```

3. 配置 Django 连接 PostgreSQL

```bash
# 编辑Django项目的settings.py文件
vim /www/django_project/你的项目名/settings.py

# 修改数据库配置部分：
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'django_vue_db',  # 你创建的数据库名
        'USER': 'db_user',        # 你创建的数据库用户
        'PASSWORD': '你的数据库密码',
        'HOST': '127.0.0.1',      # 本地访问
        'PORT': '5432',           # PostgreSQL默认端口
    }
}

# 修改ALLOWED_HOSTS（允许服务器IP/域名访问）
ALLOWED_HOSTS = ['你的服务器公网IP', 'localhost', '127.0.0.1']

# 关闭DEBUG模式（生产环境必须）
DEBUG = False

# 保存退出
```

4. 初始化 Django 数据库并测试运行

```bash
# 执行数据库迁移（创建表结构）
python manage.py makemigrations
python manage.py migrate

# 创建超级管理员（可选，用于后台管理）
python manage.py createsuperuser  # 按提示输入用户名、邮箱、密码

# 先测试Django自带服务器（确保代码无问题）
python manage.py runserver 0.0.0.0:8000
# 本地浏览器访问：http://服务器IP:8000，能正常访问则后端基础配置完成
# 按Ctrl+C停止测试服务器
```

5. 用 Gunicorn 启动 Django（生产环境）

```bash
# 测试Gunicorn启动（后台运行，绑定8000端口）
gunicorn --workers=4 --bind=0.0.0.0:8000 你的项目名.wsgi:application
# --workers=4：根据4核配置设置，通常为CPU核心数，充分利用4核性能
# 再次访问http://服务器IP:8000，能访问则Gunicorn配置正常
# 按Ctrl+C停止

# 创建Gunicorn服务配置（实现开机自启、后台运行）
vim /etc/systemd/system/django.service

# 粘贴以下内容（替换路径和项目名）：
[Unit]
Description=Django Gunicorn Service
After=network.target postgresql.service

[Service]
User=root
WorkingDirectory=/www/django_project
ExecStart=/www/django_project/venv/bin/gunicorn --workers=4 --bind=0.0.0.0:8000 你的项目名.wsgi:application
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target

# 保存退出后，启动并设置开机自启
systemctl daemon-reload
systemctl start django
systemctl enable django

# 验证服务状态（显示active (running)则正常）
systemctl status django
```

# 四、安装 Node.js 与部署 Vue 3 前端

1. 安装 Node.js（适配 Vue 3）

```bash
# 安装Node.js 18.x（LTS版本，稳定适配Vue 3）
curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
apt install -y nodejs

# 验证安装（显示版本则正常）
node -v
npm -v

# 升级npm并安装cnpm（国内镜像，加速依赖安装）
npm install -g npm
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

2. 上传 Vue 代码并打包

```bash
# 创建前端项目目录
mkdir -p /www/vue_project
cd /www/vue_project

# 方式1：Git拉取代码
git clone 你的Vue项目Git地址 .

# 方式2：本地上传（本地终端执行）
# scp -r 本地Vue项目路径 root@服务器IP:/www/vue_project/

# 安装前端依赖（优先用cnpm加速）
cnpm install

# 打包Vue项目（生成dist目录，用于Nginx部署）
# 注意：先修改Vue的.env.production文件，将后端接口地址改为服务器IP
cnpm run build:prod  # 不同项目可能是npm run build，根据package.json调整
```

# 五、安装 Nginx 并配置反向代理

1. 安装 Nginx

```bash
apt install -y nginx

# 启动并设置开机自启
systemctl start nginx
systemctl enable nginx

# 验证状态（active (running)则正常）
systemctl status nginx
```

2. 配置 Nginx 反向代理（前端 + 后端）

```bash
# 备份默认配置
mv /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak

# 创建新配置文件
vim /etc/nginx/sites-available/default

# 粘贴以下内容（替换服务器IP和项server {
    listen 80;
    server_name 43.137.41.36;

    # 配置Vue前端静态文件
    location / {
        root /www/small_target/Small_Target/FrontEnd/Small_Target/dist;  # Vue打包后的dist目录
        index index.html index.htm;
        try_files $uri $uri/ /index.html;  # 解决Vue路由刷新404
    }

    # 配置Django后端接口反向代理（匹配/api开头的请求）
    location /api/ {
        proxy_pass http://127.0.0.1:8000;  # 转发到Gunicorn的端口
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 配置Django后台管理静态文件（可选）
    location /static/ {
        alias /www/small_target/Small_Target/BackEnd/static/;  # Django的static目录
    }
}/;  # Django的static目录
    }
}

# 保存退出后，检查配置文件语法
nginx -t

# 重新加载Nginx配置（无需重启，平滑生效）
nginx -s reload
```

# 六、最终测试与性能优化

1. 最终访问测试
- 本地浏览器访问 `http://你的服务器IP`：能看到 Vue 前端页面，说明前端部署成功。

- 操作前端触发后端接口请求（如登录、查询）：能正常返回数据，说明反向代理和 Django 后端正常。

- 访问 `http://你的服务器IP/admin`：能进入 Django 后台，说明后台管理配置正常。
2. 4 核 4GB 配置专属优化

PostgreSQL 性能调优

```bash
# 编辑PostgreSQL配置文件
vim /etc/postgresql/14/main/postgresql.conf

# 修改以下参数（适配4核4GB内存）：
shared_buffers = 1GB          # 内存的1/4，4GB内存设为1GB
effective_cache_size = 2GB    # 内存的1/2，设为2GB
work_mem = 64MB               # 每个连接的工作内存，4核可适当调高
max_connections = 100         # 最大连接数，避免过多连接占用资源
maintenance_work_mem = 256MB  # 维护操作内存

# 保存后重启PostgreSQL
systemctl restart postgresql
```

Gunicorn 优化

```bash
# 编辑Django服务配置
vim /etc/systemd/system/django.service

# 修改ExecStart行，增加超时和日志配置：
ExecStart=/www/django_project/venv/bin/gunicorn --workers=4 --bind=0.0.0.0:8000 --timeout=60 --access-logfile /www/django_project/logs/access.log --error-logfile /www/django_project/logs/error.log 你的项目名.wsgi:application

# 创建日志目录
mkdir -p /www/django_project/logs

# 重启服务
systemctl daemon-reload
systemctl restart django
```

# 

# 数据库自动备份

 你想要在 Ubuntu 生产环境中为 PostgreSQL 配置定期自动备份，适配你的 Nginx + Vue3 + Django 技术栈，核心需求是实现**自动化、可配置、易恢复**的备份策略。下面我会给你一套完整的、开箱即用的解决方案。

## 一、整体实现思路

1. **编写备份脚本**：使用 PostgreSQL 官方的 `pg_dump` 工具（避免 Navicat 依赖问题），脚本包含备份、压缩、过期文件清理、日志记录等功能。

2. **配置免密登录**：避免定时任务执行时需要手动输入数据库密码。

3. **设置定时任务**：通过 `crontab` 配置定期执行备份脚本。

4. **验证备份有效性**：确保脚本和定时任务正常运行。

## 二、步骤 1：编写自动化备份脚本

### 1.1 创建备份目录

   首先创建专门的备份目录（建议非网站根目录，避免被误删）：

```bash
# 创建备份目录和日志目录
mkdir -p /data/postgres_backup/{backup,logs}
# 设置权限（确保 postgres 用户可读写）
chown -R postgres:postgres /data/postgres_backup
chmod -R 750 /data/postgres_backup
```

### 1.2 编写备份脚本

   创建脚本文件 `postgres_auto_backup.sh`：

```bash
#!/bin/bash
# ===================== 配置项（根据你的环境修改）=====================
# PostgreSQL 配置
DB_USER="你的Django数据库用户名" # 比如 django_user
DB_NAME="你的Django数据库名" # 比如 django_vue_db
DB_HOST="localhost" # 本地数据库填localhost
DB_PORT="5432" # 默认端口
# 备份配置
BACKUP_DIR="/data/postgres_backup/backup" # 备份文件存储目录
LOG_DIR="/data/postgres_backup/logs" # 日志目录
RETENTION_DAYS=7 # 保留7天的备份，自动删除更早的
BACKUP_SUFFIX=$(date +%Y%m%d_%H%M%S) # 备份文件时间戳
# ===================== 脚本核心逻辑 =====================
# 创建日志文件
LOG_FILE="${LOG_DIR}/backup_${BACKUP_SUFFIX}.log"
touch ${LOG_FILE}
# 输出日志头
echo "=====================================" >> ${LOG_FILE}
echo "PostgreSQL 自动备份开始: $(date)" >> ${LOG_FILE}
echo "=====================================" >> ${LOG_FILE}
# 执行备份（自定义格式，恢复效率高）
pg_dump -U ${DB_USER} -h ${DB_HOST} -p ${DB_PORT} -d ${DB_NAME} -F c -f ${BACKUP_DIR}/${DB_NAME}_${BACKUP_SUFFIX}.dump >> ${LOG_FILE} 2>&1
# 检查备份是否成功
if [ $? -eq 0 ]; then
echo "备份成功: ${BACKUP_DIR}/${DB_NAME}_${BACKUP_SUFFIX}.dump" >> ${LOG_FILE}
```

# 压缩备份文件（可选，节省空间）

```bash
 gzip ${BACKUP_DIR}/${DB_NAME}_${BACKUP_SUFFIX}.dump >> ${LOG_FILE} 2>&1
 echo "备份文件已压缩: ${BACKUP_DIR}/${DB_NAME}_${BACKUP_SUFFIX}.dump.gz" >> ${LOG_FILE}
```

# 删除过期备份（保留RETENTION_DAYS天）

```bash
 find ${BACKUP_DIR} -name "${DB_NAME}_*.dump.gz" -mtime +${RETENTION_DAYS} -delete >> ${LOG_FILE} 2>&1
 echo "已删除 ${RETENTION_DAYS} 天前的过期备份" >> ${LOG_FILE}
else
 echo "备份失败！请检查数据库连接或权限" >> ${LOG_FILE}
 exit 1
fi
```

# 输出日志尾

```
echo "=====================================" >> ${LOG_FILE}
echo "备份结束: $(date)" >> ${LOG_FILE}
echo "=====================================" >> ${LOG_FILE}
exit 0
```

### 1.3 配置脚本权限

```bash
# 移动脚本到备份目录
mv postgres_auto_backup.sh /data/postgres_backup/
# 添加执行权限
chmod +x /data/postgres_backup/postgres_auto_backup.sh
# 归属postgres用户（避免权限问题）
chown postgres:postgres /data/postgres_backup/postgres_auto_backup.sh
```

## 三、步骤 2：配置 PostgreSQL 免密登录

为了让脚本执行时不需要手动输入密码，需要配置 `.pgpass` 文件：

```bash
# 切换到postgres用户
su - postgres
# 创建.pgpass文件
touch ~/.pgpass
# 写入配置（格式：主机:端口:数据库名:用户名:密码）
echo "${DB_HOST}:${DB_PORT}:${DB_NAME}:${DB_USER}:你的数据库密码" >> ~/.pgpass
# 设置严格权限（必须是600，否则PostgreSQL会忽略）
chmod 600 ~/.pgpass
# 退出postgres用户
exit
```

## 四、步骤 3：配置 crontab 定时任务

### 4.1 编辑定时任务

```bash
# 切换到postgres用户（建议用postgres用户执行，权限更安全）
su - postgres
# 编辑crontab
crontab -e
```

### 4.2 添加定时规则

在打开的编辑器中添加以下内容（根据你的需求选择）：

```bash
# 每天凌晨2点执行备份（推荐生产环境）
0 2 * * * /data/postgres_backup/postgres_auto_backup.sh
# 可选：每小时备份（测试环境用）
# 0 */1 * * * /data/postgres_backup/postgres_auto_backup.sh
```

- `0 2 * * *` 含义：分钟(0) 小时(2) 日(*) 月(*) 周(*)，即每天凌晨2点执行。

- 保存退出（vim编辑器按 `ESC` → 输入 `:wq` → 回车）。
  
  ### 4.3 验证定时任务

```bash
# 查看postgres用户的定时任务
crontab -l
# 重启crontab服务（确保生效）
sudo systemctl restart cron
```

## 五、步骤 4：验证备份是否生效

### 5.1 手动执行脚本测试

```bash
# 切换到postgres用户
su - postgres
# 执行脚本
/data/postgres_backup/postgres_auto_backup.sh
# 查看日志（确认无报错）
cat /data/postgres_backup/logs/backup_*.log
# 查看备份文件
ls /data/postgres_backup/backup/
```

  如果日志显示“备份成功”，且备份目录有 `.dump.gz` 文件，说明脚本正常。

### 5.2 验证恢复（关键！确保备份可用）

```bash
# 解压备份文件
gzip -d /data/postgres_backup/backup/你的备份文件.dump.gz
# 恢复到测试数据库（先创建空库）
createdb -U ${DB_USER} test_backup_db
pg_restore -U ${DB_USER} -d test_backup_db /data/postgres_backup/backup/你的备份文件.dump
# 检查数据是否正常（比如查看Django的表）
psql -U ${DB_USER} -d test_backup_db -c "SELECT * FROM auth_user LIMIT 1;"
```

```bash
pg_restore -U postgres -h localhost -p 5432 -d smalltarget_restore E:\Python\smalltarget_20260216_142019.dump
```

## 六、适配你的技术栈的额外建议

1. **Django 侧注意**：
   
   - 确保备份的数据库用户有 `pg_catalog` 权限，能完整备份 Django 的所有表（包括 auth、session 等内置表）。
   - 如果使用了 Django 的 `migrations`，备份后建议记录迁移版本，恢复时避免迁移冲突。

2. **Nginx 侧注意**：
   
   - 备份目录不要放在 Nginx 可访问的目录（如 `/var/www/html`），避免备份文件被外网访问。
   
   - 可配置 Nginx 禁止访问 `.dump` `.log` 后缀文件（在 nginx.conf 中添加）：
     
     ```nginx
     location ~* \.(dump|log)$ {
     deny all;
     }
     ```

3. **进阶：备份文件异地存储**：
   生产环境建议将备份文件同步到云存储（如阿里云OSS、腾讯云COS），避免服务器故障丢失备份。

---

### 总结

1. **核心方案**：通过 `pg_dump` 编写自动化备份脚本，结合 `crontab` 实现定时执行，解决 Navicat 备份的依赖问题。
2. **关键配置**：`.pgpass` 免密登录是定时任务正常运行的核心，必须确保权限为600。
3. **必做验证**：手动执行脚本+检查日志+测试恢复，确保备份可用（生产环境尤其重要）。
   这套方案适配你的 Nginx + Vue3 + Django 技术栈，是 Ubuntu 生产环境中 PostgreSQL 备份的标准做法，能有效避免外键、序列等依赖导致的恢复失败问题。

# 要实现异步任务（长耗时所需）

1、安装redis服务

```bash
# 更新软件源
sudo apt update
# 安装 Redis
sudo apt install redis-server -y
# 启动并设置开机自启
sudo systemctl start redis-server
sudo systemctl enable redis-server
# 验证 Redis
redis-cli ping  # 返回 PONG 则成功
```

2、安装Python依赖（进入项目虚拟环境）

```bash
# 也可以通过requirements.txt安装
pip install celery==5.2.7 redis==4.5.5 django-redis==5.2.0
```

安装 Celery Worker 托管工具

```bash
# 安装 supervisor
sudo apt install supervisor -y
# 启动并设置开机自启
sudo systemctl start supervisor
sudo systemctl enable supervisor
```

配置 supervisor 托管 Celery Worker

```bash
sudo vim /etc/supervisor/conf.d/celery.conf
```

写入以下内容

```ini
[program:celery_worker]
directory=/path/to/your/django/project  # 项目根目录
command=/path/to/your/venv/bin/celery -A 你的项目名 worker --loglevel=info --concurrency=4
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=ubuntu  # 运行用户（避免 root）
redirect_stderr=true
stdout_logfile=/var/log/celery/worker.log  # 日志文件
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=10
```

创建日志目录并授权

```bash
sudo mkdir -p /var/log/celery
sudo chown ubuntu:ubuntu /var/log/celery
```

重启 supervisor 生效

```bash
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start celery_worker
# 验证状态：返回 RUNNING 则成功
sudo supervisorctl status celery_worker
```
